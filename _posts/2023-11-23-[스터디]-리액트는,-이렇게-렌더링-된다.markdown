---
layout: post
title: [스터디] 리액트는, 이렇게 렌더링 된다.
# date: 2017-09-12 13:32:20 +0900
date: 2023-11-23 13:13:20 +0900
description: 리액트의 렌더링에 대해 알아보자! # Add post description (optional)
img: 2023-11-23.jpg # Add image post (optional)
fig-caption: # Add figcaption (optional)
tags: [리액트, 렌더링, 가상DOM, react, fiber, rendering]
---

*해당 글은 모던 리액트 Deep Dive 2장을 읽고 정리한 내용입니다.* 

## *이번 글에서는?*

> [!Check]
> 브라우저 렌더링 원리를 다시 꼼꼼히 살펴보고, 리액트의 가상 DOM 의 원리까지 이해할 수 있습니다.
> 리액트 렌더링에서의 핵심은 **파이버**. 파이버를 알면 리액트의 작동 원리와 Why React? 에 대한 답변이 가능해 질 것입니다!

> [!Warning]
> 1.  클래스형 컴포넌트에 관련해서는 정리하지 않았습니다.
> 2. 리액트를 처음 공부하고 있어, 핵심 위주로 정리한 점 양해 부탁드립니다. 


---

## *브라우저는 이렇게 그립니다*

브라우저의 렌더링 과정은, 쉽게 말해 뼈에 살을 붙이는 방식으로 진행됩니다.
뼈(HTML), 살(CSS)라고 생각하면 쉬운데요, 그려야 할 구조들을 파악한 뒤 디자인을 붙이는 과정입니다.
뼈대가 먼저 있어야 살을 붙일 수 있겠죠? 말로 하는 것보단 정리된 이미지부터 보면서 시작해볼까요?


 ![브라우저 렌더링]({{site.baseurl}}/assets/img/browser-rendering.png)

HTML을 파싱하던 브라우저는, CSS를 만나면 CSS를 파싱하고 CSSOM(CSS 노드 트리)를 제작합니다.
만들어 놓은 DOM 노드를 순회하는 데, 지금 당장 사용자에게 보여지는 노드에만 방문합니다.
보여지지 않을 요소까지 방문하고 살을 붙일 필요는 없기 때문입니다.

브라우저는 **보여질 요소의 위치를 어디에 놓을 지 계산** 후, 앞서 만들어 둔 CSSOM 에서 해당 노드의 정보를 찾아 **실질적인 디자인을 입혀줍니다**. 색상과 같은 스타일링을요.

CSS 가 붙여지는 과정은 둘로 나뉘어지고, 과정을 이해했으니 용어를 정리해봅시다 :)


> [!Wrap up]
> **레이아웃** - 브라우저의 어느 좌표에 나타나야 하는지 계산. 레이아웃 거치면 반드시 페인팅이 일어난다.
**페인팅** - 레이아웃 단계를 거친 노드에 디자인을 입힘.

여기서 우리는 살짝 묘한 냄새를 맡을 수 있습니다. 한 번 상상해볼까요?
멋드러진 효과도 없고, 요소의 변화가 단 하나도, 혹은 거의 없는 사이트... 쉽게 떠오르시나요?

그나마 색상만 변한다면 한 번 색깔만 훅 칠하고 끝나겠지만, 마우스를 올리면 안 보이던 메뉴가 보이기도 하고, 
보이던 요소를 안 보이게 바꿔치기 하기도 하고, 안 보이던 요소가 옆에서 스윽 날아와 기존에 있던 요소를 밀쳐내고 멋진 애니메이션을 보여주기도 합니다.

그렇다는 얘기는? 
***레이아웃과 페인팅이 빈번하게 일어나고, DOM 요소에도 변화가 일어난다면, 이 과정이 반복된다는 의미입니다.*** 

---

## *그래서 리액트의 가상 DOM이*

리액트하면 초짜든 고수든 무조건 아는 가상 DOM 이 여기서 유래된 것입니다.
저는 현재 Vue, Nuxt를 사용하고 있고, 리액트는 학부 시절 살짝만 공부하고 만 게 전부인데요. 

그런 저도 리액트? 가상 DOM? 이 절로 나올 정도이죠 :)

***가상 DOM은, 바뀐 요소만 싹 바꿔치기 하고싶은 개발자의 바람에서 비롯된 내용입니다***

현재 표시할 DOM을 하나 저장해놓고, 변경할 준비가 끝나면 실제 브라우저의 DOM 에 반영됩니다.
메모리에서 한 번 계산해줌으로써, 브라우저의 부담을 줄여주는 것입니다.
브라우저보다 무조건 빠르진 않지만, 웬만한 애플리케이션은 다 굴릴 수 있다, 라고 합니다.

---

## *리액트 파이버는 비동기로 동작하며 융통성 있습니다.*

- 객체입니다. 
- 파이버 재조정자가 관리합니다.
- 가상 DOM, 실제 DOM 을 비교하고, 변경 사항을 체크합니다.
- 둘 사이에 차이가 있다면, 변경에 관련된 정보를 갖고 있는 파이버를 기준으로 화면에 렌더링을 요청합니다.

### *융통성이라면 얼마나?*

- 작업은 작은 단위로 쪼개질 수 있고, 우선순위를 매겨 중요한 요소부터 처리할 수도 있습니다.
- 잠깐 미뤄뒀다가 나중에 다시 시작할 수도 있고, 이전 작업을 재사용할 수도 있습니다. 
- 굳이 필요 없는 경우라면 폐기할 수도 있습니다.

### *그럼 과거에는 이렇지 않았단 건가요?*

네. 과거 리액트의 조정 알고리즘은, **스택 알고리즘**으로 이뤄져 있습니다. 
쌓이면 쌓이는대로, 곧이곧대로 순서를 지키는 FM 이었다는 것입니다. 
자바스크립트는 싱글 스레드이니, 한 번 시작한 동기 작업은 중단할 수가 없습니다.

---

## *파이버는 하나의 작업 단위*

파이버는 작업을 하나씩 처리하고, finishedWork()로 마무리합니다. 
이 작업은 커밋되고, 실제 DOM 에 반영됩니다. 

파이버의 작업 단계는 두 단계로, 렌더와 커밋입니다. 사실 융통성이 발휘되어야 할 부분은 렌더과정입니다. 
그리는 과정에서 비동기로 처리해야 렌더링 효율을 챙길 수 있겠죠 :)

커밋은 사실상 모든 과정을 마무리한 뒤 반영하기 위해 commitWork()를 실행하는 것이고, 
이는 동기로 동작합니다. 렌더 과정에서 변경 사항을 다 체크한 뒤 반영하기 때문에, 
작업을 중단할 지 말 지 결정권이 있을 필요도 없겠죠. 당연히 중단될 수 없습니다!


> [!Remember]
> ***파이버는 융통성 있다는 걸 잊지 마세요***
> 
리액트 요소와 가장 큰 차이점은, 웬만하면 재사용한다 라는 부분입니다.
파이버는 렌더링의 효율을 위해 고안된 개념입니다. 효율을 위해 만들어졌는데, 
재사용해도 되는 부분을 굳이 새로 만들 필요는 없습니다. 
컴포넌트가 최초 마운트 될 때 만들어지고, 이후에는 가급적 재탕됩니다.


---

## *그래서 파이버는 뭔데요*

먼저 제가 공부하면서 적은 내용으로 간략하게 이해해보세요!
이 이미지는 크게 보셔야 할 것 같아서 상당히 큽니다 😅

![파이버에 대하여]({{site.baseurl}}/assets/img/about-fiber.png)

파이버는, tag, stateNode, child, sibling, return 을 갖습니다.

- **tag** 는 element와 1:1 관계이고, 아주 다양한 값과 연결될 수 있습니다. 
우리가 알고 있는 친숙한 타입으로는, HostComponent(웹의 div 와 같은 요소), FunctionComponent,
ClassComponent 등 입니다. tag를 보면 얘가 뭔 지 알 수 있다는 거죠~

- **stateNode** 는, 파이버에 대한 참조 정보를 갖고 있고, 이 참조로 파이버와 관련된 내용에 접근합니다. 

**child, sibling, return** 은 뭘까요? 
- 파이버는 children 의 개념이 없습니다. 
- index로 자신의 위치를 구분하고, 아직 작업을 처리하지 못한 props를 갖고, 그 props 를 다 처리하면 memorized. 기억해두고 관리합니다. 
- 상태 업데이트, 콜백 함수, DOM 업데이트 등 작업을 보관해두는 큐도 있습니다. 

### *파이버 트리는 두 개*

리액트는 파이버 트리로 현재 트리, 작업 중인 트리. 이렇게 두 개의 트리를 갖습니다.
바꿔치기 작업이 끝나면? 내가 보고 있던 트리를 뒤로하고 작업을 마친 트리를 바라봅니다. (포인터를 변경한다)
이것을 ***더블 버퍼링***이라고 합니다. 

사이트에서 다 그려지지 않은 모습을 보여준다면, 사용자들은 엥? 스러울 겁니다. 
그래서 더블 버퍼링 기법을 사용하는 것입니다. 
업데이트를 반영하는 동안, 보이지 않는 한 켠에서 작업을 마무리하고, 
그게 완성되면 바꿔서 보여주는 것이죠!

더블 버퍼링, 즉 새로운 트리로 옮겨가는 이 과정은 
***커밋 단계***에서 수행됩니다. 렌더에서 변경 사항을 체크하고, 그 요청을 커밋한다고 했었죠!

반영을 마치고 옮겨가게 된 트리, workInProgress 트리는, 작업을 마친 뒤 current 트리가 될 겁니다. 
그리고, 또 다른 업데이트 사항이 있다면, 또 다른 workInProgress 로 옮겨가고. 그 옮겨간 트리가 current 트리가 되고..... 그 과정의 반복일 것입니다.


> [!Wrap up]
> - 아직 작업을 처리하지 못한 props : pendingProps 
> - 그걸 처리하고 기억해놓음 : memorizedProps 
> - 작업에 대해 보관해두는 : updateQueue

> [!Wrap up]
> updateQueue는...
> 
> - 함수형 컴포넌트의 훅 목록과 모든 훅 리스트를 저장 : memorizedState
> - 반대편 트리를 가리키는 alternate  


---

## *파이버의 작업 순서 (여기서부터 작성 중)*

![렌더링에 대하여 1]({{site.baseurl}}/assets/img/rendering1.jpg)

![렌더링에 대하여 2]({{site.baseurl}}/assets/img/rendering2.jpg)







 




















