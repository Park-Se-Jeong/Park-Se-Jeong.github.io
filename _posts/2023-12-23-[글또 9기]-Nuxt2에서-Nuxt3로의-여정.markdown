---
layout: post
title: "[글또 9기] Nuxt2에서 Nuxt3로의 여정"
# date: 2017-09-12 13:32:20 +0900
date: 2023-12-23 19:51:20 +0900
description: Nuxt2에서 Nuxt3로 옮겨가면서 느꼈던 점들을 적어봤어요.  # Add post description (optional)
img: /2023-12-23/2023-12-23.png # Add image post (optional)
fig-caption: # Add figcaption (optional)
tags: [글또, Nuxt.js]
---

프로젝트 도중, 아주 슬픈 소식을 알게되었습니다.   
그것은 바로.. **Vue2의 지원 종료!**


![Vue2 지원 종료]({{site.baseurl}}/assets/img/2023-12-23/vue2_notice.png)

크헉.. 이건, 더이상 마이그레이션을 미룰 수 없었어요.   
기존에 nuxt2와 너무 달라졌다는 이유로 계속 마이그레이션이 미뤄지고 있었던 터라,   
이 이상 지체할 순 없겠다고 생각하고 먼저 적극적으로 마이그레이션에 대한 의견을 냈습니다.   

`그럼 작은 프로젝트부터 한 번 nuxt3로 만들어 봐라.` 라는 지시를 받고 옜-썰! 했죠 ㅎㅎ   
nuxt3는 꽤 많은 점이 달랐습니다.   
간단한 랜딩 페이지 하나 만들어 보는데 일주일은 걸린 것 같아요.   

뭐가 달라졌을 지 한 번 살펴보시죠 ㅎㅎ

<br>

---

<br>


## vite 가 기본 번들러
사실 이게 진짜 좋았습니다. Nuxt2는 vite 와 잘 호환이 안 됐거든요.   
혼자서 vite 는 얼마나 빠른 지 궁금해서 실험해보려고 했을 때는 nuxt2하고   
거의 호환이 잘 안 됐어요. `nuxt-bridge`를 이용해서 맞춰야 하는 걸로 알고 있는데,   
그냥.. `처음부터 nuxt3로 만드는 게 속 편합니다.`

Nuxt3에서는 기본으로 vite 를 사용하고, webpack 도 원한다면 사용할 수 있다고 합니다.   
얼마나 빠른 지는 .. 왜 당돌하게 이름에 vite (빠른) 을 걸어놨는 지 알겠네 라고 했다면 와닿으실까요?   

제가 느낀 점은... 이 두가지가 제일 컸는데요.

> **최초 빌드 시간 엄청 짧음**   
> **핫 리로딩도 훨씬 빠르게 진행됨**


`Webpack` 은, 쉽게 말하면 **js 파일을 몽땅 가져와서 번들링합니다**.   
그래도 번들 로드를 최적화 할 수 있는 방법이 많습니다.   
번들 파일을 여러 개로 분리해서 병렬로 받아오거나, lazy loading 으로 받아와서   
로딩 속도를 개선할 순 있습니다. 그래도, 자바스크립트 기반 번들링이기 때문에   
`esbuild`하고 속도 싸움은 좀 한계가 있습니다.

`esbuild`는 Go 언어를 기반으로 만들어진 번들러입니다.  
이렇게 빠른 이유가 정리되어 있습니다.

![왜 esbuild 는 빠른가 1]({{site.baseurl}}/assets/img/2023-12-23/why_esbuild_fast1.png)

어유....^^ 길다.. 이렇게만 보시면 돼요.

> - **Go 언어로 작성**: esbuild는 Go 언어로 작성되어 기본 코드로 컴파일. 다른 js 기반 번들러보다 훨씬 빠른 성능.
>
> - **병렬성 설계**: Go는 병렬 처리를 위해 설계됨. 스레드 간 메모리 공유 가능. 반면, js는 스레드 간 데이터 직렬화가 필요하고, 가비지 수집이 더 비효율적.
>
> - **강력한 병렬 처리 사용**: esbuild는 모든 사용 가능한 CPU 코어를 최대한 활용하도록 설계된 알고리즘을 사용. 파싱,링킹,코드 생성 등을 효율적으로 병렬 처리.
>
> - **처음부터 맞춤 제작**: esbuild는 모든 구성 요소를 처음부터 맞춤 제작하여 성능 최적화를 구현함. 데이터 구조의 일관성을 유지하고, 필요시 광범위한 아키텍처 변경 가능.
>
> - **메모리 효율적 사용**: esbuild는 메모리 접근 속도, 데이터 표현의 최소화를 고려하여 컴파일러 작업을 효율적으로 처리함. 전체 JavaScript AST를 최소한의 통과로 처리해 CPU 캐시에서 데이터를 효율적으로 재사용함.


왜 esbuild 를 열심히 설명했느냐..? 맞슴다. `vite 가 esbuild랑 짝꿍임~`

**바뀌지 않는 부분은 사전에 묶어놓고**,   
**계속 수정하는 부분은 브라우저의 esm 을 사용해서 빠르게 처리합니다.**   
요청 받은 모듈만 뭔가 처리를 하니까, 속도가 빠른거였습니다. 

실제로 프로젝트 진행하면서, 아 진짜 빠르다..는 매번 느꼈습니다.  
와.. 비트 선배님 완전 무대를 뒤집어 놓으셔따.. 진짜 최고의 번들러!
비트. 리듬. 쏘울. 그대로 그냥... 와~ 였습니다.

ㅎㅎ 근데 공통적으로 찾아본 글들에서 전부, code splitting, css 관련 처리가 미흡해   
**프로덕션 단계에서는 Rollup이랑 같이 쓴다.** 라는 말을 적어놓으셨는데,   
차라리 이 파트는 나중에 따로 번들러의 역사로 써봐야 할지...

<br>

---

<br>

## Typescript 기본 지원
Typescript 를 기본적으로 지원해주기 때문에 별도로 크게 설정해 줄 필요가 없어요.

저희는 이제야 Typescript 를 도입하고 있어서, Nuxt2에서의 ts 세팅과 Nuxt3에서의 ts 세팅이 얼마나 다른 지는 정확히 알고 있진 못 해요.   


그래도, Nuxt3는 기본적으로 Nuxt2보다 개발자가 쉽게 환경을 세팅하고 코드를 짤 수 있도록 배려한 게 많았어요.   

<br>

---

<br>

## Composition API 기본 사용 가능!

원래 Nuxt2에서는 기본이 Options API 입니다.   
새로운 파일 만들 때 귀찮아서 코드 스니펫 만들어 놓은 건데요,

![Options API]({{site.baseurl}}/assets/img/2023-12-23/nuxt2_template.png)

한 눈에 들어오긴 하죠? 전 보통, 로직쪽 봐야하면 그냥 methods 검색해서 쭉 찾아보고,   
데이터들 봐야하면 data 검색해서 쭉 보고, 이런 식으로 개발하긴 했어요.

간단하게 위치 찾기는 좋았는데, Composition API 보다는 관리하기 어렵고, 재사용성이 낮다. 라고 합니다.   

`Composition API 는 데이터를 그룹핑을 시킬 수 있어서,`   
데이터 흐름 파악부터 유지보수까지 기존의 Options API 보다 쉽다! 라고 합니다.   
아직 크게 프로젝트는 안 해봤는데, 편하긴 하더라구요.

![Composition API]({{site.baseurl}}/assets/img/2023-12-23/composition_example.png)

이런 느낌입니다. `setup` 키워드를 넣고 그 안에서 반응형 데이터를 상황에 맞춰 선언하고,   
로직을 짜면 되는데요. `this`랑도 어느정도 해방된 모습... 원래는,   
data 안에 데이터를 선언하고, methods 에서 로직을 짰는데요.

함수를 호출할 때도, this.doSomething(), 데이터를 가져올 때도, this.count.   
이런 식으로 가져왔는데 그것만 안 해도 벌써 편-안..

너무 포스트가 길어질 것 같아서 더 구체적으로 적진 않았지만,   
변한 부분이 많기 때문에 꼭 공식문서는 꼼꼼히 익혀둬야 겠습니다.

리액트 스벨트 뷰 다 짬뽕된 느낌이 드는 건 기분탓일까요..?   
흠흠.. 암튼.. 더 보러갑시다

<br>

---

<br>

## vuex 도 pinia 로

권장하는 상태관리 라이브러리도 `pinia` 로 바뀌었는데요.   
`state 제어`를 위해 `mutations 를 만들 필요 없이 바로 action 으로 관리`할 수도 있고,   
타입을 핸들링 할 때, 추가 작업을 해줄 필요가 없습니다.   

`vuex`의 경우, 상태를 추가하거나 수정할 때 타입 추론을 위해 d.ts 에 별도로 작성해줘야 했습니다.   
module 시스템이기 때문에, 흩어져 있는 module 파일들에 대한 타입을 추론하는 게 어렵고,

그렇기 때문에 마치 우리가 타입 파일들을 관리하는 번들러가 되어..   
타입 추론을 쉽게 할 수 있도록 연결해줘야 했습니다.

`pinia`는 `defineStore` 에서 반환하는 hook 을 이용해 store 에 쉽게 접근할 수 있습니다.   
코드로 한 번 볼까욤?   

```typescript
import { defineStore } from 'pinia';

export type UserType = {
  name: string;
  age?: number;
  address?: number;
}

export const useUserInfo = defineStore('userInfo', {
  state: () => ({
    userInfo: {},
  }),
  actions: {
    setUserInfo(userInfo: UserType) {
      this.userInfo = userInfo;
    }
  }

})

```

이렇게 하면 요녀석을 컴포넌트에서 땡겨와서 사용할 때 타입, 로직 다 쉽게 import 해와서 쓸 수 있어요.   
store 로직에서 필요한 타입까지 그 내부에서 정할 수 있으니까 관리하기도 편할 듯..

```typescript
<script setup lang="ts">
import { UserType, setUserInfo } from '../store/user'

.... 이하 생략
</script> 

```

<br>

---

<br>


## Nitro server 

흠, 얘는 좀 신기했습니다. 우선 폴더구조 잡을 때 꽤 애먹었는데 ㄱ-   
그 뒤에도 저는 기존에 express 문법에 너무 익숙해져 있어서, 쓸 때마다 약간 멈칫하게 되더라구요.   
defineEventHandler, readBody, 등등 뭐가 많았는데, 이것까지 다 설명하기엔 좀 복잡할 것 같습니다. ㅎㅎ   


공식문서를 기반으로 번역을 해보자면,   

`Nuxt3의 서버 엔진은 Nitro` 를 사용하고 있고, `개발 과정`에서는 **서버 코드와 컨텍스트 분리**를 위해   
`Rollup, Node.js 워커를 사용`합니다. server/api 및 server/middleware 에 있는 파일을 읽어   
서버 API, middleware 를 생성합니다. 

`프로덕션에서는 .output 디렉토리에 앱, 서버를 빌드`합니다.   

Node.js 모듈(폴리필 제외)을 제거하여 `가볍고`, Node.js, 서버리스, 워커, 엣지사이드 렌더링,   
또는 **순수 정적 시스템을 지원한다면 어떤 시스템에서든 배포할 수 있습니다.**

<br>

네.. 그렇습니다.   
그리고, 파일명에 엔드포인트 및 method 방식을 넣어서 로직을 짜주면 되는데요.   
 
![nitro 폴더 구조]({{site.baseurl}}/assets/img/2023-12-23/nitro_server.png)

nuxt.config.ts 에서 apiBase 를 설정해주면, 그쪽으로 요청을 지가 알아서 넣어줍니다.   
그리고 `hello.post.ts` 이렇게 해주면 HTTP method 도 한 번에 쉽게 파악 가능하구요.   

음, 근데! 보통 서비스가 커지면.. 이정도 수준에서 멈추지 않을테니, `그럼 그때마다 파일을 만들어야하나...?`   
라는 생각이 들어서 고민을 좀 했습니다. 다른 example 들을 많이 찾아보면서, 결정한 방법은

<br>

![이 구조로 선택했다]({{site.baseurl}}/assets/img/2023-12-23/server_arcitect.png)

<br>

> 1. api 파일을 [...].ts 로 만들고, 요청을 우선 여기로 다 받습니다.
> 2. controller 에 로직을 다 짜놓습니다.
> 3. 엔드포인트에 맞춰서 controller 로직을 실행할 수 있게 맞춰줍니다.

<br>

예를 들면, 이런 식으로 

![api 요청 구조]({{site.baseurl}}/assets/img/2023-12-23/file_arcitect.png)

<br>

파일을 굳이 하나하나 만들 필요 없이, 엔드포인트마다 controller 파일을 하나 만들어두고   
그 내부에서 실행할 수 있게 구조를 맞추면 그나마 편하더라구요.   

보통 웬만하면 다 CRUD 가 붙는데, 파일을 하나하나 다 만들 생각하니 끔찍했는데   
저의 짧은 식견으로 머리를 굴려봤던..(?) 사실 되게 쉬운 구조인데 생색 좀 내봤습니다.   

그 외에는 사실 백엔드 작업을 해보신 분들이라면 쉽게 적응할 수 있어서,   
예시 찾아보고 공식문서 보면서 따라하시면 될 것 같습니다 :)

nitro 에서 따로 내걸고 있는 공식문서 보면서 하시는 게 좋아요,   
nuxt 측 공식문서는 server 쪽 내용이 살짝 빈약했습니다.   

 💁‍♀️ [nitro docs 보러가기](https://nitro.unjs.io/guide/getting-started)

<br>

---

<br>

## 마치며

제가 개인적으로 사용하면서 느꼈던 점들을 정리해봤어요~   
vue, nuxt 가 궁금하셨던 분들이 있다면 읽어보시고 vue와 독자분들의   
거리감이 줄어드셨길 기원하며... 궁금한 점이나 혹시 이상한 부분이 있으면 언제든 말씀주세요!   
메리 크리스마스입니다.