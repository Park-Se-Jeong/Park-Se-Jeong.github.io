---
layout: post
title: 숨참고 HOOK DIVE (작성중)
date: 2023-11-30 15:54:20 +0900
description: 리액트 훅 요모조모 뜯어보기 # Add post description (optional)
img: 2023-11-30.png # Add image post (optional)
fig-caption: # Add figcaption (optional)
tags: [react, Hook]
---


*해당 글은 모던 리액트 Deep Dive 3장을 읽고 정리한 내용입니다.*

## 이번 글에서는?

>
> ### 리액트 Hook 에 대해 살펴봅니다 : ) 
>
> useState, useEffect, useCallback, useMemo, useRef, useReducer...   
> 훅을 이해하고 사용할 수 있게 됩니다.


>
> **자주 쓰이는 훅 위주로 정리되어 있습니다.**   
> Deep Dive 인 만큼 기본적인 개념에 대해 설명이 적은 편인데, 제가 좀 추가해 봤어요! 
> 
> useState 와 useEffect 는 좀 더 자세히 정리해봤어요. 저도 리액트 시작한 지 이제 2주째라서 문법이 익숙치 않거든요. 😂
> 
> 앞으로 저의 블로그에는 핵심 위주로 정리되어 올라갈 예정입니다.


<br>

---

<br>
## 뭘 살펴볼 지 우선 살짝!

살펴볼 훅의 리스트입니다. : )

>
> 1. **useState** - 상태
> 2. **useEffect** - 상태를 감시하는
> 3. **useMemo** - 연산부터 컴포넌트까지 기억하기 -> 컴포넌트는 React.memo로 ...
> 4. **useCallback** - 함수 기억하기
> 5. **useRef** - useState 짝퉁
> 6. **useContext** - 상태는 Context 를 타고
> 7. **useReducer** - 상태들
> 

~~책엔 있었지만, 다루지 않는 훅의 리스트입니다.~~
8. useImperativeHandle
9. useLayoutEffect
10. useDebugValue

*더 서론이 길 필요는 없을 것 같습니다 : ) 바로 고고고 !*

<br>

---

<br>

## 시작 전 기억해둬야 할 Point

> 리액트의 렌더링은 return 값을 비교하여 실행된다. 
> **렌더링 발생할 때 마다 함수는 새롭게 실행, state는 매번 초기화!** 
> 계속 강조되는 포인트입니다. 


<br>

---

<br>



## useState

**상태, 상태를 바꿔줄 함수, 초깃값.**
이 세 가지만 기억하면 useState는 쉽습니다. 

기본 문법부터 볼까요?

```javascript
const [state, setState] = useState(0)
```

`state` 는 `setState` 로 바꿔줄 수 있고, `0` 으로 초기화됐어요.

리액트에서는 state, props 의 변화를 기반으로 렌더링하기 때문에, 
데이터에 일어난 변화를 렌더링하고 싶다면 `상태관리` 를 잘 해줘야 할 것이고, 
그 상태를 다룰 수 있는 게 `useState` 입니다. 

여기까진, 제가 간략하게 개념을 Wrap Up 했구요! 

책 내부에서 강조했던 내용을 반영한 예시를 보러 가봅시다 ㅎ.ㅎ
playground 페이지에서 제가 간단히 실습해보고 예시를 가져와 봤어요! 
~~p.s 저도 리액트가 거의 처음이라 이상한 부분 있다면 둥글게 지적해주세요. ㅜ,.ㅜ~~

<br>

---

<br>



## 절대 실패 예시

![로컬 변수로 놀기]({{site.baseurl}}/assets/img/useState2.png)

<br> 


콘솔엔 test 가 잘 찍히지만 로컬 변수로 test 를 둔 것이기 때문에,   
리액트는 변화로 감지하지 않아요. 그래서 렌더링이 다시 일어날 수 없어요.    
제가 아무리 버튼을 클릭해도, 콘솔창만 지저분해지고 뷰에는 아무런 일도 없어요. 


<br>

---

<br>

## 편-안한 예시

![이게 useState]({{site.baseurl}}/assets/img/useState1.png)


이렇게 하고, 버튼을 누르면 test 엔 랜덤한 수가 잘 나와요. 
`useState` 로 상태를 잘 지정해줬고, 상태를 위한 함수도 잘 실행해줬고, 
리액트는 그걸 감지해서 다시 잘 그려준거에요 : )

이제 useState 를 알았으니 구조도 알아야하는데, 구조의 핵심은 `Closure` 입니다.   
👉 Closure 개념이 헷갈리신다면 여기로.... <https://ko.javascript.info/closure>

즉시실행함수로 현재 index 를 가둬놓고, 나중에도 계속 이 동일한 index 로 접근할 수 있어요.
***즉, 의존성 배열에 담긴 요소들은 자신만의 index 를 갖고 있고, 필요할 때마다 그 값을 가져오는 거에요.***


이제, 저처럼 lazy 한 녀석 하나 보러갑시다.


<br>

---

<br>

## 게으른 초기화

게으른 초기화는, 말 그대로 게으름 그 자체인데요.   
**최초 렌더링 됐을 때 딱 한 번 실행**되고, **그 뒤로는 무시**돼요.   
아무리 리렌더링이 돼도, 다시 실행되지 않습니다.  



우선, 게으른 초기화는   
이럴 때 사용하라고 공식문서에 적혀 있어요.

>
> 1. 초깃값이 복잡할 때
> 2. 무거운 연산을 포함하고 있을 때 
>

역시 이미지로 보는 게 눈에 더 잘 들어올 것 같네요 ㅎㅎ

제가 적용해 본 예시는, 배열에 대한 접근이었는데요.
map 을 한 번 돌릴 수 있게 해봤어요.

![게으른 초기화 예시]({{site.baseurl}}/assets/img/useState-lazy-initialize.png)

간단하게 조건에 부합하는 지 반환하게 만들어 보고,
정말 한 번 실행된 후로는 리렌더링 되도 무시되는지 로그에 찍어봤어요. 


![게으른 초기화 예시]({{site.baseurl}}/assets/img/useState-lazy-console.png)

정말.. 게으르네요. 잘 되고 있나 봅니다.


책에서는 이런 경우 사용하는 걸 권장하고 있어요. 

- `localStorage, sessionStorage`에 접근할 때
- `배열`에 접근할 때 (ex) map, filter, find, ...etc
- `복잡한 로직` 을 거쳐야 할 때


useState 는 드디어 끝! 이제 useEffect 로 가봅시다.

<br>

---

<br>

## useEffect

**useEffect 는 의존성 배열에 담긴 값이 바뀌면, 함수를 실행해줍니다.** 
배열을 채울수도 있고, 비워둘 수도 있고, 아예 빼버릴 수도 있어요.

> 1. `채우면` 말 그대로 그 안에 담긴 데이터를 보고 변화가 있으면 함수를 실행해요   
> 2. `비워놓으면` 최초 렌더링 때 실행된 후, 의존할 데이터가 없으니 거기서 끝나요
> 3. `아예 빼면` 렌더링 될 때마다 계속 실행돼요

useEffect 는 사실 이 정도면 정리할 게 없을 것 같아요. 문법도 간결해서요.

vue 를 위주로 쓰고 있는 저에겐, watch 처럼 느껴져서 낯설지 않았는데요.
vue에서도 watch 할 데이터 값을 넣어주면, 제가 정의해 둔 함수를 실행해주거든요. 
혹시 여기서 vue 는 어떨 지 궁금한 분들이 있을까요..? 그건 나중에 글로 쓸 거에요. 푸하하


변화를 감지하고, 함수를 실행할 수 있다는 건 `이전 값` 을 기억해뒀기 때문에 가능하다는 건데, 
그래서 `클린업 함수`의 중요성을 책에서 특히 강조하신 것 같아요.

**useEffect 내에서 반환되는 함수가 클린업 함수 입니다!** 



```javascript
useEffect(() => {

...
window.addEventListener('click', somethingHappen)
...
..
.
return () => {
	window.removeEventListner('click', somethingHappen)
}
...
})
```


`클린업 함수`는, **실행은** 렌더링이 **새로되고 나서 실행**되는데, **실행할 때의 값은 이전 값을 보고** 실행돼요.
그래서 이벤트를 등록하고 클린업 함수로 잘 지워줘야 하는 거랍니다.
클린업 함수에게 과거는 과거일 뿐.. 마땅히 청소해야 할 것들을 청소하는 과정입니다.



## useEffect 사용 시 주의사항

우선! 무슨 내용인 지만 간단하게 훑고 갑시다.

> 1. 의존성 배열은 웬만하면 비우지 마세요 
> 2. 실행할 함수에 이름을 붙여주세요
> 3. 로직이 과도하게 커지는 건 피해주세요 
> 4. 굳이 불필요한 외부 함수를 만들진 마세요




<br>

---

<br>

## useMemo

말 그대로 Memo. 연산의 결과, 컴포넌트 둘 다 기억해 둘 수 있습니다. 
컴포넌트를 메모이제이션 할 때는, React.memo 를 쓰는 게 더 현명하지만..
의존성 배열에 넣어놓은 값에 변화가 있다면, 
콜백을 실행하고 다시 그 결괏값을 저장해둡니다.

음.. 얜 좀 와닿지가 않아서, 저도 그냥 처음부터 다 쳐볼게요.

```javascript

function ExpensiveComponent({ value }) {
  useEffect(() => {
    console.log('rendering!')
  })
  return <span>{ value + 1000 }</span>

}
function App() {
  const [value, setValue] = useState(10)
  const [, triggerRendering] = useState(false)
  const memorized = useMemo(
    () => <ExpensiveComponent value={value}></ExpensiveComponent>, 
    [value]
  )

  function handleChange(e) {
    setValue(Number(e.target.value))
  } 

  function handleClick(e) {
    triggerRendering(prev => !prev)
  } 

  return (
    <>
    <input value={value} onChange={handleChange} />
    <button onClick={handleClick}>렌더링 발생!</button>
    {memorized}
    </>
  )
}

```


<br>

---

<br>

## useCallback

useCallback 은 넘겨받은 callback 을 기억해둡니다.   
함수를 새로 만들지 않고, 기억해두고 계속 씁니다!   

함수가 계속 재생성되는 건, 메모리를 잡아먹는다는 의미이고   
결국 성능에 영향을 미친다는 의미가 되는데요.   

이 예시를 보면 이해할 수 있으실 겁니다 😊

(작성중...)


```javascript

```


<br>

---

<br>

## useRef


<br>

---

<br>

## useContext

<br>

---

<br>

## useReducer

### 



### 



---

## 



> 
> 
> 



---


































