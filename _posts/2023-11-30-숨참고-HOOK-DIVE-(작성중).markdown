---
layout: post
title: 숨참고 HOOK DIVE (작성중)
date: 2023-11-30 15:54:20 +0900
description: 리액트 훅 요모조모 뜯어보기 # Add post description (optional)
img: 2023-11-30.png # Add image post (optional)
fig-caption: # Add figcaption (optional)
tags: [react, Hook]
---


*해당 글은 모던 리액트 Deep Dive 3장을 읽고 정리한 내용입니다.*

## 이번 글에서는?

>
> ### 리액트 Hook 에 대해 살펴봅니다 : ) 
>
> useState, useEffect, useCallback, useMemo, useRef, useReducer...   
> 훅을 이해하고 사용할 수 있게 됩니다.


>
> **자주 쓰이는 훅 위주로 정리되어 있습니다.**   
> Deep Dive 인 만큼 기본적인 개념에 대해 설명이 적은 편인데, 제가 좀 추가해 봤어요! 
> 
> useState 와 useEffect 는 좀 더 자세히 정리해봤어요. 저도 리액트 시작한 지 이제 2주째라서 문법이 익숙치 않거든요. 😂
> 
> 앞으로 저의 블로그에는 핵심 위주로 정리되어 올라갈 예정입니다.


<br>

---

<br>
## 뭘 살펴볼 지 우선 살짝!

살펴볼 훅의 리스트입니다. : )

>
> 1. **useState** - 상태
> 2. **useEffect** - 상태를 감시하는
> 3. **useMemo** - 연산부터 컴포넌트까지 기억하기 -> 컴포넌트는 React.memo로 ...
> 4. **useCallback** - 함수 기억하기
> 5. **useRef** - useState 짝퉁
> 6. **useContext** - 상태는 Context 를 타고
> 7. **useReducer** - 상태들
> 

~~책엔 있었지만, 다루지 않는 훅의 리스트입니다.~~
8. useImperativeHandle
9. useLayoutEffect
10. useDebugValue

*더 서론이 길 필요는 없을 것 같습니다 : ) 바로 고고고 !*

<br>

---

<br>

## 시작 전 기억해둬야 할 Point

> 리액트의 렌더링은 return 값을 비교하여 실행된다. 
> **렌더링 발생할 때 마다 함수는 새롭게 실행, state는 매번 초기화!** 
> 계속 강조되는 포인트입니다. 


<br>

---

<br>



## useState - 상태는 useState가 해결했다굿

**상태, 상태를 바꿔줄 함수, 초깃값.**
이 세 가지만 기억하면 useState는 쉽습니다. 

기본 문법부터 볼까요?

```javascript
const [state, setState] = useState(0)
```

`state` 는 `setState` 로 바꿔줄 수 있고, `0` 으로 초기화됐어요.

리액트에서는 state, props 의 변화를 기반으로 렌더링하기 때문에, 
데이터에 일어난 변화를 렌더링하고 싶다면 `상태관리` 를 잘 해줘야 할 것이고, 
그 상태를 다룰 수 있는 게 `useState` 입니다. 

여기까진, 제가 간략하게 개념을 Wrap Up 했구요! 

책 내부에서 강조했던 내용을 반영한 예시를 보러 가봅시다 ㅎ.ㅎ
playground 페이지에서 제가 간단히 실습해보고 예시를 가져와 봤어요! 
~~p.s 저도 리액트가 거의 처음이라 이상한 부분 있다면 둥글게 지적해주세요. ㅜ,.ㅜ~~

<br>

---

<br>



## 절대 실패 예시

![로컬 변수로 놀기]({{site.baseurl}}/assets/img/useState2.png)

<br> 


콘솔엔 test 가 잘 찍히지만 로컬 변수로 test 를 둔 것이기 때문에,   
리액트는 변화로 감지하지 않아요. 그래서 렌더링이 다시 일어날 수 없어요.    
제가 아무리 버튼을 클릭해도, 콘솔창만 지저분해지고 뷰에는 아무런 일도 없어요. 


<br>

---

<br>

## 편-안한 예시

![이게 useState]({{site.baseurl}}/assets/img/useState1.png)


이렇게 하고, 버튼을 누르면 test 엔 랜덤한 수가 잘 나와요. 
`useState` 로 상태를 잘 지정해줬고, 상태를 위한 함수도 잘 실행해줬고, 
리액트는 그걸 감지해서 다시 잘 그려준거에요 : )

이제 useState 를 알았으니 구조도 알아야하는데, 구조의 핵심은 `Closure` 입니다.   
👉 Closure 개념이 헷갈리신다면 여기로.... <https://ko.javascript.info/closure>

즉시실행함수로 현재 index 를 가둬놓고, 나중에도 계속 이 동일한 index 로 접근할 수 있어요.
***즉, 의존성 배열에 담긴 요소들은 자신만의 index 를 갖고 있고, 필요할 때마다 그 값을 가져오는 거에요.***


이제, 저처럼 lazy 한 녀석 하나 보러갑시다.


<br>

---

<br>

## 게으른 초기화 - 힘든 일은 다시 반복하고 싶지 않은 마치 like 직장인

게으른 초기화는, 말 그대로 게으름 그 자체인데요.   
**최초 렌더링 됐을 때 딱 한 번 실행**되고, **그 뒤로는 무시**돼요.   
아무리 리렌더링이 돼도, 다시 실행되지 않습니다.  



우선, 게으른 초기화는   
이럴 때 사용하라고 공식문서에 적혀 있어요.

>
> 1. 초깃값이 복잡할 때
> 2. 무거운 연산을 포함하고 있을 때 
>

역시 이미지로 보는 게 눈에 더 잘 들어올 것 같네요 ㅎㅎ

제가 적용해 본 예시는, 배열에 대한 접근이었는데요.
map 을 한 번 돌릴 수 있게 해봤어요.

![게으른 초기화 예시]({{site.baseurl}}/assets/img/useState-lazy-initialize.png)

간단하게 조건에 부합하는 지 반환하게 만들어 보고,
정말 한 번 실행된 후로는 리렌더링 되도 무시되는지 로그에 찍어봤어요. 


![게으른 초기화 예시]({{site.baseurl}}/assets/img/useState-lazy-console.png)

정말.. 게으르네요. 잘 되고 있나 봅니다.


책에서는 이런 경우 사용하는 걸 권장하고 있어요. 

- `localStorage, sessionStorage`에 접근할 때
- `배열`에 접근할 때 (ex) map, filter, find, ...etc
- `복잡한 로직` 을 거쳐야 할 때


useState 는 드디어 끝! 이제 useEffect 로 가봅시다.

<br>

---

<br>

## useEffect - 의존성 배열 악개

**useEffect 는 의존성 배열에 담긴 값이 바뀌면, 함수를 실행해줍니다.** 
배열을 채울수도 있고, 비워둘 수도 있고, 아예 빼버릴 수도 있어요.

> 1. `채우면` 말 그대로 그 안에 담긴 데이터를 보고 변화가 있으면 함수를 실행해요   
> 2. `비워놓으면` 최초 렌더링 때 실행된 후, 의존할 데이터가 없으니 거기서 끝나요
> 3. `아예 빼면` 렌더링 될 때마다 계속 실행돼요

useEffect 는 사실 이 정도면 정리할 게 없을 것 같아요. 문법도 간결해서요.

vue 를 위주로 쓰고 있는 저에겐, watch 처럼 느껴져서 낯설지 않았는데요.
vue에서도 watch 할 데이터 값을 넣어주면, 제가 정의해 둔 함수를 실행해주거든요. 
혹시 여기서 vue 는 어떨 지 궁금한 분들이 있을까요..? 그건 나중에 글로 쓸 거에요. 푸하하


변화를 감지하고, 함수를 실행할 수 있다는 건 `이전 값` 을 기억해뒀기 때문에 가능하다는 건데, 
그래서 `클린업 함수`의 중요성을 책에서 특히 강조하신 것 같아요.

**useEffect 내에서 반환되는 함수가 클린업 함수 입니다!** 



```javascript
useEffect(() => {

...
window.addEventListener('click', somethingHappen)
...
..
.
return () => {
	window.removeEventListner('click', somethingHappen)
}
...
})
```


`클린업 함수`는, **실행은** 렌더링이 **새로되고 나서 실행**되는데, **실행할 때의 값은 이전 값을 보고** 실행돼요.
그래서 이벤트를 등록하고 클린업 함수로 잘 지워줘야 하는 거랍니다.
클린업 함수에게 과거는 과거일 뿐.. 마땅히 청소해야 할 것들을 청소하는 과정입니다.



## useEffect 사용 시 주의사항

우선! 무슨 내용인 지만 간단하게 훑고 갑시다.

> 1. 의존성 배열은 웬만하면 비우지 마세요 
> 2. 실행할 함수에 이름을 붙여주세요
> 3. 로직이 과도하게 커지는 건 피해주세요 
> 4. 굳이 불필요한 외부 함수를 만들진 마세요

TODO: 내용 추가..


<br>

---

<br>

## useMemo - 다양하게 재탕

말 그대로 Memo. 연산의 결과, 컴포넌트 둘 다 기억해 둘 수 있습니다. 
(컴포넌트는 React.memo 를 사용하는 게 더 현명한 방법이라고 합니다.)

`의존성 배열`에 넣어놓은 값에 변화가 있다면,   
`콜백을 실행하고 다시 그 결괏값을 저장`해둡니다.

음.. 얜 좀 와닿지가 않아서, 저도 그냥 처음부터 다 쳐볼게요.

```javascript

function ExpensiveComponent({ value }) {
  useEffect(() => {
    console.log('rendering!')
  })
  return <span>{ value + 1000 }</span>

}
function App() {
  const [value, setValue] = useState(10)
  const [, triggerRendering] = useState(false)
  const memorized = useMemo(
    () => <ExpensiveComponent value={value}></ExpensiveComponent>, 
    [value]
  )

  function handleChange(e) {
    setValue(Number(e.target.value))
  } 

  function handleClick(e) {
    triggerRendering(prev => !prev)
  } 

  return (
    <>
    <input value={value} onChange={handleChange} />
    <button onClick={handleClick}>렌더링 발생!</button>
    {memorized}
    </>
  )
}

```

- triggerRendering 으로 렌더링을 강제로 발생시켰지만, memorized 는 리렌더링 되지 않습니다.
- 의존성으로 선언된 value 가 변경될 때까지, memorized 는 꿋꿋하게 존버합니다..


<br>

---

<br>

## useCallback - Callback 재탕

useCallback 은 넘겨받은 callback 을 기억해둡니다.   
함수를 새로 만들지 않고, 기억해두고 계속 씁니다!   

`함수가 계속 재생성되는 건, 메모리를 잡아먹는다`는 의미이고   
결국 **성능에 영향을 미친다**는 의미가 되는데요.   

이 예시를 보면 이해할 수 있으실 겁니다 😊



```javascript
const ChildComponent = memo(({name, value, onChange}) => {
  useEffect(() => {
    console.log('rendering', name)
  })

  return (
    <>
      <h1>
        {name} {value ? '켜짐' : '꺼짐'}    
      </h1>
      <button onClick={onChange}>toggle</button>
    </>
  )
})

function App() {
  const [status1, setStatus1] = useState(false)
  const [status2, setStatus2] = useState(false)

  const toggle1 = () => { setStatus1(!status1) }
  const toggle2 = () => { setStatus2(!status2) }

  return (
    <>
      <ChildComponent name="1" value={status1} onChange={toggle1}></ChildComponent>
      <ChildComponent name="2" value={status2} onChange={toggle2}></ChildComponent>
    </>
  )

}
```

`ChildComponent` 는 `name, value, onChange` 를 props 로 받아서 그립니다.   
name, value, onChange 가 바뀌지 않는 한 리렌더링 되지 않습니다.      
toggle1 쪽 버튼을 클릭하면, 그 ChildComponent 만 바뀌어야 할텐데...    
이렇게 되면, `모든 ChildComponent 가 다시 리렌더링`됩니다. 왜 그럴까요?
   
      


> App 의 입장에서는, state 가 바뀌기 때문에 리렌더링됩니다.   
> ChildComponent 는 그때마다 새롭게 생성된 toggle 함수를 props 로 받습니다.    
> 버튼을 하나만 클릭해도 양쪽이 다 바뀌는 매직이 벌어집니다... 


useCallback 을 이용해서, useMemo 와 마찬가지로 기억해 둘 수 있습니다.   
use는 약간 재탕을 의미하는 접두사같은 느낌인데요, useCallback 은 말 그대로   
첫 번째 인수로 받아온 callback 을 메모이제이션 하는겁니다!   

그리고, useEffect를 사용할 때처럼, `기명함수`를 넘겨주면   
나중에 디버깅하기 용이합니다 :)


useMemo와 useCallback 의 차이는 `어떤 대상을 기억해둘거냐`일 뿐,   
역할은 같습니다. 깊이 생각할 필요는 없을 듯 합니다.


<br>

---

<br>

## useRef - DOM DOM DOM 대문을 열어라

`useState` 인 듯 아닌 useRef.   
이 둘은 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장합니다.   
대신, 큰 차이점이 있습니다.

- `useRef`는 반환값인 객체 내부에 있는 current 로 값에 접근, 변경할 수 있습니다.   
- `useRef`는 **그 값이 변경돼도 리렌더링이 일어나지 않습니다.**

<br>

### useRef는 왜 필요할까요?

`렌더링 영향`을 줄이고 싶은거라면, 전에 봤던 useState 예제처럼   
로컬 변수로 두고 관리해도 괜찮지 않을까요? 

이 방식은 이런 단점들이 있습니다. 

1. 렌더링이 되지 않았어도, `메모리를 차지`합니다.
2. 컴포넌트가 여러 번 생성되면, 각 컴포넌트가 모두 value 를 가리킵니다. 
  - 대부분의 경우, **컴포넌트 당 하나의 값을 필요로 하는 것이 일반적**입니다.


이 단점을 모두 극복한 리액트식 접근법이 바로 `useRef` 입니다.

보통 `DOM 에 접근하고 싶을 때` 사용합니다.   
그럼, 렌더링이 되기 전에 접근하면 **undefined** 을 반환하겠죠?

`렌더링을 발생시키지 않고 원하는 상태값을 저장할 수 있다는 것`이 포인트인데요.   
이 예시를 한 번 살펴봅시다! 


```javascript
function usePrevious(value) {
  const ref = useRef()
  
  useEffect(() => {
    ref.current = value
  }, [value])
  
  return ref.current
}

function someComponent() {
  const [counter, setCounter] = useState(0)
  const previousCounter = usePrevious(counter)
  
  function handleClick() {
    setCounter((prev) => prev + 1)
  }

  return (
    <button onClick={handleClick}>
      {counter} {previousCounter}
    </button>
  )
}
```

이렇게 해서, 렌더링을 일으키지 않고 이전 counter 에 저장되어 있던 값을   
보관할 수 있게 되었네요 👀

<br>

---

<br>
## useContext - 흐름으로 넘겨주마 (작성중)...

<br>

---

<br>

## useReducer

<!-- ### -->



<!-- ###  -->


<!-- --- -->

<!-- ##  -->






---


































